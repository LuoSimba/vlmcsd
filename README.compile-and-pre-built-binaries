Compilation and pre-built binaries FAQ
======================================

哪个预编译版本最适合我的系统（或我的设备）？
----------------------------------------------------------

没有这样的版本.
最好的版本肯定是由你自己编译得到的版本--因为你系统
自带的工具链是各个方面都经过优化的（最适合当前环境的）。

    respect （事物的）方面，细节；尊重
    in every respect 各个方面


我应该怎样编译，才能得到属于我自己的可执行文件？
-------------------------------

在成熟的桌面发行版中还是相对比较容易的。

    full blown: fully developed
    full blown desktop system: 这里指那些各方面都成熟的，稳定的发行版

1. 安装 GCC

2. 如果 GCC 不是默认的编译器，你可以执行 "make CC=gcc" 来显式指定 GCC 作为编译器。

3. 进入到 vlmcsd 目录，并执行 "make". （我的 make 版本会执行 GNUmakefile 里的内容）
   马上你就可以得到以下两个产品：

   * vlmcs 
   * vlmcsd  

    right away:
    (注意与 right now 不一样)强调动作的迅速。
    这里接在 be built 动作后面，表示立马就可以编译完成。



How do I compile a binary for my embedded device?
-------------------------------------------------

What you need is cross-compiling toolchain for your device. It consists of a
C compiler, libraries, header files and some tools (called binutils). The
toolchain must match the device in processor architecture, endianess, ABI,
library and header files version, library configuration, ...

If the endianess or ABI differs or the version of some library between
toolchain and device differs too much, the resulting binary does not run
on your device.

Once you have a proper toolchain (probably found on the Internet for download),
unpack it to any directory and type

     "make CC=/path/to/toolchain/bindir/c-compiler-binary"

Building vlmcsd for using a cross-compiling toolchain is as easy as building
vlmcsd for your local machine. The only question is, whether this you have
a toolchain that actually matches your device.

Whenever you change any parameter of the make command line, you must "clean"
the source directory from intermediate files and output from previous runs
of make. You can do so by typeing "make clean" or force make to behave as if
the directory were clean by adding -B to the command line, e.g.

     "make -B CC=/path/to/toolchain/bindir/c-compiler-binary"


I have downloaded several promising toolchains for my device but they all
don't work. Can I create my own toolchain?
-------------------------------------------------------------------------

You can use tools like buildroot or OpenWRT. Both are able to create toolchains
for many embedded devices. But this is out of the scope of this document.
If you are unable to walk through thousands of configuration options and make
the right choice, you may probably want to try the pre-built binaries.


如何选择一个预编译版本?
---------------------------------

二进制文件所在的目录结构如下：

binaries
+
+--<操作系统>
   +
   +--<CPU 架构>
      +
      +--<endianess> (omitted if CPU or OS does not allow multi-endianess)
         +
         +--<C-library>

<C-library> can also be "static". That means no special library is required.
Static binaries are much bigger and need more RAM than dynamic binaries but
are more likely to run on your system. Use a static binary only, if none of
the dynmic binaries run.

Don't get confused when a binary is named after an OS or a specific device,
e.g. the name contains "openwrt", "tomato" or "Fritzbox". This does not mean
that the binary will run only on that OS or on that device. It is a hint only
where I got or built the toolchain from.


如何确定我的系统的字节序？
--------------------------------------------

    endian: 字节序
    big-endian: 大端字节序
    little-endian: 小端字节序
    virtually: almostly, 几乎，实际上
    virtually does not exist: 几乎不存在

- 所有的英特尔 CPU 一定是小端。(指x86, x32, x64)
- Windows 系统一定是小端，即使 CPU 支持大端
- 大端的 ARM 极其罕见. 你可以直接假设它是小端

你可以尝试执行：

     echo -n I | od -o | awk 'FNR==1{ print substr($2,6,1)}'

如果返回 1 是小端系统
如果返回 0 是大端系统.

注意！有些设备没有 "od" 这个命令，因此这个方法就行不通。


